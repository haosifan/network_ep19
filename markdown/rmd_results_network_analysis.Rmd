---
title: "results_network_analysis"
author: "Stefan Haußner"
date: "25 Juli 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(dplyr)
library(data.table)
```

```{r echo = FALSE, results = "hide"}
source("../scripts/build_igraph.R")
```

# Analyse der MEPs

## In- und Outdegree: 

Welche MEPs folgen besonders vielen anderen im Netzwerk oder werden besonders gefolgt

```{r echo = F, warning = F}
g_degree_out <- igraph::degree(net_igraph, mode = "out")
g_degree_in <- igraph::degree(net_igraph, mode = "in")
```

Der Abgeordnete mit den meisten Followern (innerhalb der MEPs) ist Frans Timmermans (520 MEPs folgen ihm). Diejenige Abgeordnete, die den meisten anderen MEPs folgt ist Tomáš ZDECHOVSKÝ (EPP, Czech Rep.), der 586 von 621 twitter-aktiven MEPs folgt.

```{r echo = F, warning = F}
which.max(g_degree_out)
filter(d_mep_twitter_adj, twitter_id == names(which.max(g_degree_out)))

which.max(g_degree_in)
filter(d_mep_twitter_adj, twitter_id == names(which.max(g_degree_in)))
```

Top20 der MEPs sowohl der ausgehenden als auch der eingehenden Kontakte. Die Tabellen wären auch nach nach Fraktionen oder Nationen aufteilbar.

```{r echo = F, warning = F, tidy = T}
top20_eu_in <- as.data.frame(g_degree_in) %>% 
  rownames_to_column("twitter_id") %>%
  mutate(twitter_id = as.numeric(twitter_id)) %>% 
  select(twitter_id, indegree = g_degree_in) %>% 
  left_join(.,d_mep_twitter_adj, by = c("twitter_id" = "twitter_id")) %>% 
  arrange(-indegree) %>% 
  tbl_df() %>%
  .[1:20,]
kable(top20_eu_in, caption = "Most followers")

```

```{r echo = F, warning = F, tidy = T}
top20_eu_out <- as.data.frame(g_degree_out) %>% 
  rownames_to_column("twitter_id") %>%
  mutate(twitter_id = as.numeric(twitter_id)) %>% 
  select(twitter_id, outdegree = g_degree_out) %>% 
  left_join(.,d_mep_twitter_adj, by = c("twitter_id" = "twitter_id")) %>% 
  arrange(-outdegree) %>% 
  tbl_df() %>%
  .[1:20,]
kable(top20_eu_in, caption = "Most followings")
```

## Betweenness

Welche Knoten müssen besonders oft durchlaufen werden, um im Netzwerk zu einem bestimmten Knoten zu kommen.

Anders gesagt: welcher MEP ist besonders zentral im Netzwerk, weil er besonders viele andere MEPs auf kürzestem Weg miteinander verbindet.

```{r echo = F, warning = F, tidy = T}
library(igraph)
g_betweenness <- igraph::betweenness(net_igraph, directed = TRUE,
                        normalized = TRUE)

top_10_betweenness <- as.data.frame(g_betweenness) %>%
  rownames_to_column("twitter_id") %>% 
  select(twitter_id, betweenness = g_betweenness) %>%
  mutate(twitter_id = as.numeric(twitter_id)) %>% 
  arrange(-betweenness) %>% 
  left_join(.,d_mep_twitter_adj, by = c("twitter_id" = "twitter_id")) %>% 
  .[1:10,] %>% 
  tbl_df()
kable(top_10_betweenness, caption = "Top10 - betweenness")
```

## Eigenvector centrality

Statistisch ein bisschen fortgeschrittener als die betweenness. Hoher Eigenvector-Wert heißt, dass der Knoten mit besonders vielen anderen Knoten verbunden ist, besonders stark aber mit anderen Knoten, die ihrerseits wieder mit vielen verbunden sind.

```{r echo = F, warning = F}
g_ev <- eigen_centrality(net_igraph, directed = T)$vector

top_10_eigencentrality <- as.data.frame(g_ev) %>%
  rownames_to_column("twitter_id") %>% 
  mutate(twitter_id = as.numeric(twitter_id)) %>% 
  select(twitter_id, ev_centrality = g_ev) %>% 
  arrange(-ev_centrality) %>% 
  left_join(.,d_mep_twitter_adj, by = c("twitter_id" = "twitter_id")) %>%  
  .[1:10,] %>% 
  tbl_df()
kable(top_10_eigencentrality, caption = "Top10 - Eigenvector centrality")
```

# Analyse des Netzwerks

## Edge Density
Proportion of vertices that actually exist, out of all potential existing. Kann also als Prozentzahl gesehen werden. Die Zahl alleine sagt noch nicht allzuviel aus. Man kann aber randomisation tests machen, indem man x Netzwerke simuliert, die in etwa ähnlich zu dem vorhandenen sind und schaut, ob die "Edge Density" besonders auffällt. 

Hier könnte man auch die Density nur innerhalb von pol. Gruppen vergleichen und die "dichteste" Gruppe rausstellen etc.

```{r echo = F, warning = F}
edge_density(net_igraph)*100
```

## Average Path length

Beschreibt die durchschnittliche Pfadlänge, die man zurücklegen muss um zu einem anderen Knoten zu kommen. Der durchschnittliche Weg zwischen zwei Knoten also. Den finde ich hier mit `r mean_distance(net_igraph, directed=T)` auf Anhieb recht kurz, aber auch damit kann man random tests machen. Grundsätzlich hieße das aber, man kann fast immer zu einem guten "Multiplikator-MEP" kommen und über den zum Ziel (2,5 Schritte).

```{r echo = F, warning = F}
mean_distance(net_igraph, directed = T)
```

Tatsächlich ist der Weg angeblich sogar relativ lang. Jedenfalls übernatürlich lang für ein Netzwerk der gleichen edge_density wie in unserem Originalnetzwerk. Davon habe ich 1000 simuliert und die Kanten werden zufällig zwischen die gleiche Anzahl an Knoten gesetzt. Für alle wird dann die MeanDistance errechnet und in einem Histogramm dargestellt. Das sieht jetzt schon relativ gestaucht aus, weil die alle eine mean_distance von 2.23 - 2.28 haben. Da liegt unsere mean_distance (rote Linie) dann signifikant drüber.

Letztlich könnten wir über so Techniken jedenfalls schauen, ob das MEP Netzwerk abweicht von Netzwerken, die die gleiche Anzahl von Knoten haben. Hier wäre die Interpretation, der Weg zwischen den MEPs ist länger, als bei anderen Netzwerken mit gleicher Anzahl von Knoten und der gleichen Dichte von Verbindungen. Gesamt gesehen scheinen MEPs bei Twitter sich also eher unterdurchschnittlich oft zu folgen, was an Fraktionsbildung etc. liegen könnte. Man folgt eben nicht dem politischen Feind.

```{r echo = F, warning = F}
#sample_gnp(n = gorder(net_igraph), p = edge_density(net_igraph), directed = T)

# Generate 1000 random graphs

g_random <- vector('list',1000)

for(i in 1:1000){
  
  g_random[[i]] <- sample_gnp(n = gorder(net_igraph), 
                              p = edge_density(net_igraph), 
                              directed = T)
}

g_random_apl_meandis <- unlist(lapply(g_random, mean_distance, directed = T))

n_meandistance <- mean_distance(net_igraph, directed = T)
if (min(g_random_apl_meandis) > n_meandistance) {
  xlim_l <- n_meandistance
  xlim_u <- max(g_random_apl_meandis)
} else {
  xlim_l <- max(g_random_apl_meandis)
  xlim_u <- n_meandistance
}

hist(g_random_apl_meandis, breaks = 40, xlim = range(xlim_l, xlim_u))
abline(v = mean_distance(net_igraph, directed=T), col = "red", lty = 3, lwd=2)
```

## Transitivity

Gerade in Sozialen Netzwerken wichtig. Perfekte Transitivität würde bedeuten das X und Y miteinander verbunden sind, Y und Z auch und Z und X ebenfalls. Ab solchen Dreierkonstellationen, bei denen jeder mit jedem verbunden ist, redet man von Cliquen (siehe unten). Das ist in real vorkommenden Netzwerken allerdings selten. Der Transitivitäts-Koeffizient misst die Wahrscheinlichkeit, dass die benachbarten Knoten eines Knotens ebenfalls miteinander verbunden sind. Dies wird manchmal auch als Clustering-Koeffizient bezeichnet. In unserem Fall ist die Wahrscheinlichkeit bei etwas mehr als einem Viertel (wieder durch randomisation testbar, ob das viel oder wenig ist).

Die Transitivität kann auch lokal für jeden Knoten errechnet werden. Er nimmt dann quasi alle 3er-Konstellationen wo dieser Knoten dabei ist und guckt sich die beiden anderen Knoten an.

Hinweis: Ob das Netzwerk gerichtet ist oder nicht, wird dabei außer Acht gelassen.

```{r echo = F, warning = F}
#triangles(net_igraph)
transitivity(net_igraph)
```

Bei gleicher "Dichte" des Netzwerks ist es bei unserem Netzwerk deutlich wahrscheinlicher, dass auch die Nachbarn eines Knotens miteinander verbunden sind. Wieder ist das ganz gut über die Fraktionsbildung zu erklären. Bei Parteikollegen die sich gegenseitig folgen, ist es relativ wahrscheinlich, dass die beiden auch dem dritten Parteikollegen folgen.

```{r echo = F, warning = F}
g_random_trans <- unlist(lapply(g_random, transitivity))

n_transitivity <- transitivity(net_igraph)
if (min(g_random_trans) > n_transitivity) {
  xlim_l <- n_transitivity
  xlim_u <- max(g_random_trans)
} else {
  xlim_l <- max(g_random_trans)
  xlim_u <- n_transitivity
}

hist(g_random_trans, breaks = 40, xlim = range(xlim_l, xlim_u))
abline(v = transitivity(net_igraph), col = "red", lty = 3, lwd=2)
```

## Cliquen

Cliquen sind Zusammenschlüsse von Knoten, die alle gegenseitig miteinander verbunden sind. In unserem Netzwerk gibt es `r count_max_cliques(net_igraph)` "größte" Cliquen die gleich groß sind. Diese verbinden jeweils `r clique_num(net_igraph)` Knoten miteinander.

```{r echo = F, warning = F}
largest.cliques(net_igraph)
#max_cliques(net_igraph) 
```

## Assortativity

Der Assortativitätskoeffizient ist positiv, wenn ähnliche Knoten (basierend auf einer externen Eigenschaft) dazu neigen verbunden zu sein. Andernfalls ist er negativ. Theoretisch kann man hier diese externe Eigenschaft auch angeben, da stürzt mein R allerdings einfach ab.

In Standardfall wird die Assortativity auf Grundlage der Degrees (s.o.) berechnet. Also: Sind Knoten mit besonders vielen ein- und ausgehenden Kanten auch mit anderen high-degree-Knoten verbunden. Hier ist der Koeffizient `r round(assortativity.degree(net_igraph, directed=T),2)`. Man kann also nicht sagen, dass besonders zentrale Knoten anderen zentralen Knoten besonders stark folgen, aber auch nicht das Gegenteil. Das könnte dafür sprechen, dass es bspw. in jeder Fraktion Multiplikatoren gibt, die potentiell nur den high-degree-MEPs aus den anderen Fraktionen folgen und sonst eher den lower-degree-MEPs aus ihrer eigenen Fraktion.

```{r echo = F, warning = F}
assortativity.degree(net_igraph, directed=T)
```

## Reciprocity

```{r}
reciprocity(net_igraph)
```

Das Maß der Reziprozität definiert den Anteil der gegenseitigen Verbindungen in einem gerichteten Graphen. Funktioniert also nur bei gerichteten Graphen, unserer ist aber so einer, da MEP X ja bei Twitter MEP Y folgen kann, aber nicht zwangsläufig umgekehrt auch. Mit einem Wert von `r round(reciprocity(net_igraph),2)` werden knapp die Hälfte der Follower auch zurück gefolgt.

## Community Detection

Theoretisch könnte man den Algorithmus auch selber Gruppen erkennen lassen. Da wir aber bereits auch schon vorgegebene Gruppen (Nation und Fraktion und nationale Partei haben wir schon im Datensatz) haben, müssten wir das mal besprechen, ob das Sinn ergibt.

# Analyse der Fraktionen

```{r}
V(net_igraph)$GroupShort %>% unique()

subnet_epp <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "EPP")
subnet_sd <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "S&D")
subnet_green <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "Greens/EFA")
subnet_gue <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "GUE/NGL")
subnet_id <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "ID")
subnet_renew <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "Renew")
subnet_ecr <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "ECR")
subnet_ni <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "NI")


analyse_subgraphs <- function(subg_name){
  subg <- get(subg_name)
  subg_trans <- transitivity(subg)
  subg_assort <- assortativity.degree(subg, directed = T)
  subg_recip <- reciprocity(subg)
  subg_edgedens <- edge_density(subg)
  #subg_degree_out <- igraph::degree(subg, mode = "out")
  #subg_degree_in <- igraph::degree(subg, mode = "in")
  
  results_list <- list(
    groupname = unique(V(subg)$GroupShort),
    #indegree = subg_degree_in,
    #outdegree = subg_degree_out,
    edgedensity = subg_edgedens,
    transitivity = subg_trans,
    assortativity = subg_assort,
    reciprocity = subg_recip
  )
  return(results_list)
}


subgraph_results <- lapply(ls(pattern = "subnet_"), analyse_subgraphs) %>% 
  rbindlist() %>% 
  mutate(groupname = factor(groupname, levels= c("ID", "ECR", "EPP", "Renew", "S&D", "Greens/EFA", "GUE/NGL", "NI"))) %>% 
  arrange(groupname) %>% 
  mutate_if(is.numeric, round, 3)
  
kable(subgraph_results)
```



