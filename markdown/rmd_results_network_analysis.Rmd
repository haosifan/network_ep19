---
title: "results_network_analysis"
author: "Stefan Haußner"
date: "25 Juli 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(dplyr)
library(data.table)
library(kableExtra)
library(tidyverse)
library(GGally)
library(gridExtra)
library(ggpubr)
```

```{r include=FALSE}
source("../scripts/build_igraph.R")
```

# Analyse der MEPs

## In- und Outdegree: 

Welche MEPs folgen besonders vielen anderen im Netzwerk oder werden besonders gefolgt?

```{r echo = F, warning = F}
g_degree_out <- igraph::degree(net_igraph, mode = "out")
g_degree_in <- igraph::degree(net_igraph, mode = "in")

```

Der ```Grad``` eines Netzwerks ist ein einfaches Zentralitätsmaß, das zählt, wie viele Nachbarn ein Knoten hat. Wenn das Netzwerk gerichtet ist, haben wir zwei Versionen des Maßes: Der ```in-degree``` ist die Anzahl der eingehenden Verbindungen während der ```out-degree``` die Anzahl der ausgehenden Kanten ist. In einem ungerichteten Netzwerk ist der in- und der out-degree identisch.

Der Abgeordnete mit den meisten Followern (innerhalb der MEPs) ist Frans Timmermans (229 MEPs folgen ihm). Derjenige Abgeordnete, der den meisten anderen MEPs folgt ist Tomáš ZDECHOVSKÝ (EPP, Czech Rep.), der 578 von 621 twitter-aktiven MEPs folgt.

Top20 der MEPs sowohl der ausgehenden als auch der eingehenden Kontakte. Die Tabellen wären auch nach nach Fraktionen oder Nationen aufteilbar.

```{r echo = F, warning = F, tidy = T}
top20_eu_in <- as.data.frame(g_degree_in) %>% 
  rownames_to_column("twitter_id") %>%
  mutate(twitter_id = as.numeric(twitter_id)) %>% 
  select(twitter_id, indegree = g_degree_in) %>% 
  left_join(.,d_mep_twitter_adj, by = c("twitter_id" = "twitter_id")) %>% 
  arrange(-indegree) %>% 
  tbl_df() %>%
  .[1:20,]

top20_eu_in
kable(top20_eu_in, caption = "Most followers")

```

```{r echo = F, warning = F, tidy = T}
top20_eu_out <- as.data.frame(g_degree_out) %>% 
  rownames_to_column("twitter_id") %>%
  mutate(twitter_id = as.numeric(twitter_id)) %>% 
  select(twitter_id, outdegree = g_degree_out) %>% 
  left_join(.,d_mep_twitter_adj, by = c("twitter_id" = "twitter_id")) %>% 
  arrange(-outdegree) %>% 
  tbl_df() %>%
  .[1:20,]

top20_eu_out
kable(top20_eu_out, caption = "Most followings")
```

## Betweenness

Die ```Betweenness``` misst das Ausmaß, in dem ein Knoten auf Pfaden zwischen anderen Knoten liegt. Knoten mit hoher Betweenness können einen erheblichen Einfluss innerhalb eines Netzwerks haben, da sie die gegenseitige Übermittlung von Informationen beeinflussen. Sie sind auch diejenigen, deren Entfernung aus dem Netzwerk die Kommunikation zwischen anderen Knoten am meisten stört.

Welche Knoten müssen besonders oft durchlaufen werden, um im Netzwerk zu einem bestimmten Knoten zu kommen.

```{r echo = F, warning = F, tidy = T}
g_betweenness <- igraph::betweenness(net_igraph, directed = TRUE,
                        normalized = TRUE)

top_10_betweenness <- as.data.frame(g_betweenness) %>%
  rownames_to_column("twitter_id") %>% 
  select(twitter_id, betweenness = g_betweenness) %>%
  mutate(twitter_id = as.numeric(twitter_id)) %>% 
  arrange(-betweenness) %>% 
  left_join(.,d_mep_twitter_adj, by = c("twitter_id" = "twitter_id")) %>% 
  .[1:10,] %>% 
  tbl_df()

top_10_betweenness

kable(top_10_betweenness, caption = "Top10 - betweenness")
```

## Eigenvector centrality

Die ```Eigenvektorzentralität``` ist quasi die Erweiterung der degree-Zentralität. Bei der degree-Zentralität wird für jede Verbindung ein Punkt vergeben. Es sind jedoch nicht alle Knoten gleichwertig: Einige sind relevanter als andere und vernünftigerweise zählen Verbindungen zu wichtigen Knoten mehr. Daher ist die These der Eigenvektorzentralität:

> Ein Knoten ist wichtig, wenn er mit anderen wichtigen Knoten verbunden ist.

Die Eigenvektor-Zentralität unterscheidet sich von der Grad-Zentralität: Ein Knoten, der viele Verbindungen hat, muss nicht notwendigerweise eine hohe Eigenvektor-Zentralität haben (es könnte sein, dass alle Kontakte nur zu sehr wenigen anderen Knoten Kontakte haben). Darüber hinaus ist ein Knoten mit hoher Eigenvektor-Zentralität nicht notwendigerweise stark verknüpft (der Knoten kann wenige, aber wichtige Kontakte haben).


```{r echo = F, warning = F}
g_ev <- eigen_centrality(net_igraph, directed = T)$vector

top_10_eigencentrality <- as.data.frame(g_ev) %>%
  rownames_to_column("twitter_id") %>% 
  mutate(twitter_id = as.numeric(twitter_id)) %>% 
  select(twitter_id, ev_centrality = g_ev) %>% 
  arrange(-ev_centrality) %>% 
  left_join(.,d_mep_twitter_adj, by = c("twitter_id" = "twitter_id")) %>%  
  .[1:10,] %>% 
  tbl_df()
top_10_eigencentrality %>% write_csv2("../output/eigenvector_top10.csv")
kable(top_10_eigencentrality, caption = "Top10 - Eigenvector centrality")
top_10_eigencentrality
```

# Analyse des Netzwerks

## Edge Density
Proportion of vertices that actually exist, out of all potential existing. Kann also als Prozentzahl gesehen werden. Die Zahl alleine sagt noch nicht allzuviel aus. Man kann aber randomisation tests machen, indem man x Netzwerke simuliert, die in etwa ähnlich zu dem vorhandenen sind und schaut, ob die "Edge Density" besonders auffällt. 

Hier könnte man auch die Density nur innerhalb von pol. Gruppen vergleichen und die "dichteste" Gruppe rausstellen etc.

```{r echo = F, warning = F}
edge_density(net_igraph)*100
```

## Average Path length

Beschreibt die durchschnittliche Pfadlänge, die man zurücklegen muss um zu einem anderen Knoten zu kommen. Der durchschnittliche Weg zwischen zwei Knoten also. Den finde ich hier mit `r mean_distance(net_igraph, directed=T)` auf Anhieb recht kurz, aber auch damit kann man random tests machen. Grundsätzlich hieße das aber, man kann fast immer zu einem guten "Multiplikator-MEP" kommen und über den zum Ziel (2,5 Schritte).

```{r echo = F, warning = F}
mean_distance(net_igraph, directed = T)
```

Tatsächlich ist der Weg angeblich sogar relativ lang. Jedenfalls übernatürlich lang für ein Netzwerk der gleichen edge_density wie in unserem Originalnetzwerk. Davon habe ich 1000 simuliert und die Kanten werden zufällig zwischen die gleiche Anzahl an Knoten gesetzt. Für alle wird dann die MeanDistance errechnet und in einem Histogramm dargestellt. Das sieht jetzt schon relativ gestaucht aus, weil die alle eine mean_distance von 2.23 - 2.28 haben. Da liegt unsere mean_distance (rote Linie) dann signifikant drüber.

Letztlich könnten wir über so Techniken jedenfalls schauen, ob das MEP-Netzwerk abweicht von Netzwerken, die die gleiche Anzahl von Knoten haben. Hier wäre die Interpretation, der Weg zwischen den MEPs ist länger, als bei anderen Netzwerken mit gleicher Anzahl von Knoten und der gleichen Dichte von Verbindungen. Gesamt gesehen scheinen MEPs bei Twitter sich also eher unterdurchschnittlich oft zu folgen, was an Fraktionsbildung etc. liegen könnte. Man folgt eben nicht dem politischen Feind.

```{r echo = F, warning = F}
#sample_gnp(n = gorder(net_igraph), p = edge_density(net_igraph), directed = T)

# Generate 1000 random graphs

g_random <- vector('list',1000)

for(i in 1:1000){
  
  g_random[[i]] <- sample_gnp(n = gorder(net_igraph), 
                              p = edge_density(net_igraph), 
                              directed = T)
}

g_random_apl_meandis <- unlist(lapply(g_random, mean_distance, directed = T))


gg_meandistance <- ggplot()+
  geom_histogram(aes(x = g_random_apl_meandis), bins = 200)+
  geom_vline(xintercept = mean_distance(net_igraph, directed = TRUE), linetype = "dashed", size = 1, color = "red")+
  labs(x = "average path length")

```

## Transitivity

Gerade in Sozialen Netzwerken wichtig. Perfekte Transitivität würde bedeuten das X und Y miteinander verbunden sind, Y und Z auch und Z und X ebenfalls. Ab solchen Dreierkonstellationen, bei denen jeder mit jedem verbunden ist, redet man von Cliquen (siehe unten). Das ist in real vorkommenden Netzwerken allerdings selten. Der Transitivitäts-Koeffizient misst die Wahrscheinlichkeit, dass die benachbarten Knoten eines Knotens ebenfalls miteinander verbunden sind. Dies wird manchmal auch als Clustering-Koeffizient bezeichnet. In unserem Fall ist die Wahrscheinlichkeit bei etwas mehr als einem Viertel (wieder durch randomisation testbar, ob das viel oder wenig ist).

Die Transitivität kann auch lokal für jeden Knoten errechnet werden. Er nimmt dann quasi alle 3er-Konstellationen wo dieser Knoten dabei ist und guckt sich die beiden anderen Knoten an.

Hinweis: Ob das Netzwerk gerichtet ist oder nicht, wird dabei außer Acht gelassen.

```{r echo = F, warning = F}
#triangles(net_igraph)
transitivity(net_igraph)
```

Bei gleicher "Dichte" des Netzwerks ist es bei unserem Netzwerk deutlich wahrscheinlicher, dass auch die Nachbarn eines Knotens miteinander verbunden sind. Wieder ist das ganz gut über die Fraktionsbildung zu erklären. Bei Parteikollegen die sich gegenseitig folgen, ist es relativ wahrscheinlich, dass die beiden auch dem dritten Parteikollegen folgen.

```{r echo = F, warning = F}
g_random_trans <- unlist(lapply(g_random, transitivity))


gg_transitivity <- ggplot()+
  geom_histogram(aes(x = g_random_trans), bins = 500)+
  geom_vline(xintercept = transitivity(net_igraph), linetype = "dashed", size = 1, color = "red")+
  labs(x = "transitivity")
```

## Cliquen

Cliquen sind Zusammenschlüsse von Knoten, die alle gegenseitig miteinander verbunden sind. In unserem Netzwerk gibt es `r count_max_cliques(net_igraph)` "größte" Cliquen die gleich groß sind. Diese verbinden jeweils `r clique_num(net_igraph)` Knoten miteinander.

```{r echo = F, warning = F}
largest.cliques(net_igraph)
#max_cliques(net_igraph) 
```

## Assortativity

Der Assortativitätskoeffizient ist positiv, wenn ähnliche Knoten (basierend auf einer externen Eigenschaft) dazu neigen verbunden zu sein. Andernfalls ist er negativ.

In Standardfall wird die Assortativity auf Grundlage der Degrees (s.o.) berechnet. Also: Sind Knoten mit besonders vielen ein- und ausgehenden Kanten auch mit anderen high-degree-Knoten verbunden. Hier ist der Koeffizient `r round(assortativity.degree(net_igraph, directed=T),2)`. Man kann also nicht sagen, dass besonders zentrale Knoten anderen zentralen Knoten besonders stark folgen, aber auch nicht das Gegenteil. Das könnte dafür sprechen, dass es bspw. in jeder Fraktion Multiplikatoren gibt, die potentiell nur den high-degree-MEPs aus den anderen Fraktionen folgen und sonst eher den lower-degree-MEPs aus ihrer eigenen Fraktion.

Wenn man dem Assortativity-Index das externe Attribut der Fraktionszugehörigkeit mitgibt ist die Assortativity stark positiv, was die Fraktionsbildung im Netzwerk unterstreicht.

```{r echo = F, warning = F}
assortativity.degree(net_igraph, directed=T)

as.numeric(as.factor(V(net_igraph)$GroupShort))

assortativity.nominal(net_igraph, types = as.numeric(as.factor(V(net_igraph)$GroupShort)))

assortativity.nominal(net_igraph, types = as.numeric(as.factor(V(net_igraph)$country)))
```

Random Graph Model

```{r echo = F, warning = F}
g_random_assort <- unlist(lapply(g_random, assortativity.degree, directed = TRUE))

gg_assortativity <- ggplot()+
  geom_histogram(aes(x = g_random_assort), bins = 100)+
  geom_vline(xintercept = assortativity.degree(net_igraph), linetype = "dashed", size = 1, color = "red")+
  labs(x = "assortativity")
```

## Reciprocity

```{r}
reciprocity(net_igraph)
```

Das Maß der Reziprozität definiert den Anteil der gegenseitigen Verbindungen in einem gerichteten Graphen. Funktioniert also nur bei gerichteten Graphen, unserer ist aber so einer, da MEP X ja bei Twitter MEP Y folgen kann, aber nicht zwangsläufig umgekehrt auch. Mit einem Wert von `r round(reciprocity(net_igraph),2)` werden knapp die Hälfte der Follower auch zurück gefolgt.

```{r echo = F, warning = F}
g_random_recip <- unlist(lapply(g_random, reciprocity))

gg_reciprocity <- ggplot()+
  geom_histogram(aes(x = g_random_recip), bins = 500)+
  geom_vline(xintercept = reciprocity(net_igraph), linetype = "dashed", size = 1, color = "red")+
  labs(x = "reciprocity")
```

# Combine all ERGM-Graphs

```{r}

subtitle <- text_grob("Histogram shows the results of 1000 random graphs and the dashed line shows the value of the MEP network", size = 7, face = "italic")

gg_grid_ergm <- grid.arrange(gg_meandistance, gg_assortativity, gg_transitivity, gg_reciprocity, top = subtitle)
ggsave(plot = gg_grid_ergm, "../gfx/random_graph_models.png", units = "cm", width = 14, height = 10, dpi = 300)
```



## Community Detection

Theoretisch könnte man den Algorithmus auch selber Gruppen erkennen lassen. Da wir aber bereits auch schon vorgegebene Gruppen (Nation und Fraktion und nationale Partei haben wir schon im Datensatz) haben, müssten wir das mal besprechen, ob das Sinn ergibt.

Könnte aber für "Bündnisse" etc. spannend sein. Oder bspw. ob sich eine Community aus überwiegend Links-Mitte und Rechts-Mitte, oder Mitte gegen Extreme oder sowas ergibt.

# Analyse der Fraktionen

```{r}
subnet_epp <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "EPP")
subnet_sd <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "S&D")
subnet_green <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "Greens/EFA")
subnet_gue <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "GUE/NGL")
subnet_id <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "ID")
subnet_renew <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "Renew")
subnet_ecr <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "ECR")
subnet_ni <- induced.subgraph(net_igraph, V(net_igraph)$GroupShort == "NI")

analyse_subgraphs <- function(subg_name){
  subg <- get(subg_name)
  subg_trans <- transitivity(subg)
  subg_assort <- assortativity.degree(subg)
  subg_recip <- reciprocity(subg)
  subg_edgedens <- edge_density(subg)
  #subg_degree_out <- igraph::degree(subg, mode = "out")
  #subg_degree_in <- igraph::degree(subg, mode = "in")
  
  results_list <- list(
    groupname = unique(V(subg)$GroupShort),
    #indegree = subg_degree_in,
    #outdegree = subg_degree_out,
    edgedensity = subg_edgedens,
    transitivity = subg_trans,
    assortativity = subg_assort,
    reciprocity = subg_recip
  )
  return(results_list)
}


subgraph_results <- lapply(ls(pattern = "subnet_"), analyse_subgraphs) %>% 
  rbindlist() %>% 
  mutate(groupname = factor(groupname, levels= c("ID", "ECR", "EPP", "Renew", "S&D", "Greens/EFA", "GUE/NGL", "NI"))) %>% 
  arrange(groupname) %>% 
  mutate_if(is.numeric, round, 3)

#write_csv2(subgraph_results, path = "../output/subgraph_results.csv")

DT::datatable(subgraph_results)

kable(subgraph_results, escape = FALSE) %>% kable_styling(c("striped", "condensed"), full_width = F)
```

Hier erkennt man meiner Meinung nach bereits folgendes:

## Die NIs

Die NIs haben extrem hohe Werte. Die "Nicht-Fraktion" ist sehr dicht (viele Verbindungen), sie folgen sich sehr stark untereinander und folgen sich auch gegenseitig zurück. Das liegt vor allem daran, dass die NI dominiert wird, durch die Brexit-Partei und die Movimento 5 Stelle. Das diese zwei nationalen Parteien sich intern stark folgen, ergibt Sinn. Es gibt also zwei Gruppen bei den NI, die sich eben besonders stark folgen. Siehe auch Grafik.

```{r}
set.seed(1903)
plot.igraph(subnet_ni)
```

## Fraktionen mit dem dichtesten Netzwerk

Außer der NI haben die Grünen, die GUE/NGL und Renew Europe die höchste Dichte, also den höchsten Anteil an existierenden Verbindungen an allen möglichen. Könnte bspw. am Alter liegen (tendenziell jüngere Fraktionen), die dann eben social-media-affiner sind. Kommt drauf an, ob es sich lohnt hier hinterher zu forschen (Alter wäre prinzipiell möglich).

## Extreme Parteien anders als Mitte? 

Der Transitivitäts-Koeffizient misst die Wahrscheinlichkeit, dass die benachbarten Knoten eines Knotens ebenfalls miteinander verbunden sind. Hohe Werte weisen diesmal abgesehen von den NI auch die ECR und die Grünen auf. Bei der reciprocity liegen sogar ECR und ID vorne.

Könnte man ein bisschen das Argument draus machen, dass die right-wings sehr stark drauf achten, dass sie ihren Leuten auch zurück folgen, aber auch nicht unbedingt mehr (also nicht darüber hinaus auch noch nach weiteren Kolleg*innen Ausschau halten). Die ECR versucht aber eben doch so eine "Fraktionsidentität" auch auf Twitter zu konstruieren.

S&D und EPP liegen jedenfalls häufiger maximal im Mittelfeld, sind demnach eher unterdurchschnittlich vernetzt. Auch das müsste man aber eigentlich für alle nochmal mit ERGM testen.

## Fraktionsbildung geht über Eliten

Bei allen Fraktionen außer der ECR ist der Assortativity-Wert negativ. Da dieser hier auf dem degree-Wert beruht, bedeutet das, dass Gradmäßig sehr unterschiedliche MEPs sich folgen. Also diejenigen die sehr viele Follower haben etc. folgen innerhalb der Fraktion auch denjenigen, die nicht soviele Follower aus der Fraktion haben.

Hier findet demnach keine Elitenbildung auf Twitter statt, wo auch die Fraktionseliten nur anderen Fraktionseliten folgen, sondern im Vordergrund steht das statusunabhängige Folgen von Mitgliedern der Fraktion.

# Grafisch

```{r}
set.seed(1905)
plot.igraph(net_igraph)

set.seed(1905)
png(filename = "../gfx/network_complete.png")
igraph::plot.igraph(net_igraph)
dev.off()

set.seed(1236)
ggnet2(net_igraph, node.color = V(net_igraph)$color, node.size = 2, edge.alpha = 0.2)


```

Abschließend der Netzwerk-Graph insgesamt: Man sieht sehr gut, dass Fraktionen sich zusammenfinden. Außerdem lassen sich politische Lager ebenfalls erkennen. Der ECR-Knubbel ist näher an ID und EPP als am linken Spektrum. ID fällt etwas aus der allgemeinen Punktwolke heraus. Ebenfalls gibt es links oberhalb der Renew eine Gruppe grauer Knoten. Das sind die Abgeordneten der Brexit-Party.


Übersicht:

```{r}
d_mep_twitter_adj %>% 
  group_by(group) %>% 
  summarise(n = n()) %>% 
  write_csv2("accounts_per_group.csv")
```




