---
title: "MEP network | first results"
author: "Stefan Haussner"
date: "15 November 2018"
output: 
  pdf_document: default
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo = F, message = F}
source("build_igraph.R", echo = F)
```

# Analyse der MEPs

## In- und Outdegree: 

Welche MEPs folgen besonders vielen anderen im Netzwerk oder werden besonders gefolgt

```{r echo = F, warning = F}
g_degree_out <- igraph::degree(net_igraph, mode = "out")
g_degree_in <- igraph::degree(net_igraph, mode = "in")
```

Der Abgeordnete mit den meisten Followern (innerhalb der MEPs) ist Guy Verhofstadt (221 MEPs folgen ihm). Diejenige Abgeordnete, die den meisten anderen MEPs folgt ist Isa Adinolfi (ITA, M5S), die 241 weiteren MEPs folgt.

```{r echo = F, warning = F}
which.max(g_degree_out)
which.max(g_degree_in)
```

Top20 der MEPs sowohl der ausgehenden als auch der eingehenden Kontakte. Die Tabellen wären auch nach nach Fraktionen oder Nationen aufteilbar.

```{r echo = F, warning = F, tidy = T}
top20_eu_in <- as.data.frame(g_degree_in) %>% 
  mutate(mep_twitter = rownames(.)) %>% 
  select(mep_twitter, indegree = g_degree_in) %>% 
  arrange(-indegree) %>% 
  left_join(., select(names_list, screen_name, fullName, country), by = c("mep_twitter" = "screen_name")) %>% 
  .[1:20,]
kable(top20_eu_in, caption = "Most followers")
```

```{r echo = F, warning = F, tidy = T}
top20_eu_out <- as.data.frame(g_degree_out) %>% 
  mutate(mep_twitter = rownames(.)) %>% 
  select(mep_twitter, outdegree = g_degree_out) %>% 
  arrange(-outdegree) %>% 
  left_join(., select(names_list, screen_name, fullName, country), by = c("mep_twitter" = "screen_name")) %>% 
  .[1:20,]
kable(top20_eu_out, caption = "Most Following")
```

## Betweenness

Welche Knoten müssen besonders oft durchlaufen werden, um im Netzwerk zu einem bestimmten Knoten zu kommen.

Anders gesagt: welcher MEP ist besonders zentral im Netzwerk, weil er besonders viele andere MEPs auf kürzestem Weg miteinander verbindet.

```{r echo = F, warning = F, tidy = T}
library(igraph)
g_betweenness <- igraph::betweenness(net_igraph, directed = TRUE,
                        normalized = TRUE)

as.data.frame(g_betweenness) %>% 
  mutate(mep_twitter = rownames(.)) %>% 
  select(mep_twitter, betweenness = g_betweenness) %>% 
  arrange(-betweenness) %>% 
  left_join(., select(names_list, screen_name, fullName, country), by = c("mep_twitter" = "screen_name")) %>% 
  .[1:10,] %>% 
  kable(caption = "Top10 - betweenness")
```

## Eigenvector centrality

Statistisch ein bisschen fortgeschrittener als die betweenness. Hoher Eigenvector-Wert heißt, dass der Knoten mit besonders vielen anderen Knoten verbunden ist, besonders stark aber mit anderen Knoten die ihrerseits wieder mit vielen verbunden sind.

```{r echo = F, warning = F}
g_ev <- eigen_centrality(net_igraph, directed = T)$vector

as.data.frame(g_ev) %>% 
  mutate(mep_twitter = rownames(.)) %>% 
  select(mep_twitter, ev_centrality = g_ev) %>% 
  arrange(-ev_centrality) %>% 
  left_join(., select(names_list, screen_name, fullName, country), by = c("mep_twitter" = "screen_name")) %>% 
  .[1:10,] %>% 
  kable(caption = "Top10 - Eigenvector centrality")
```

# Analyse des Netzwerks

## Edge Density
Proportion of vertices that actually exist, out of all potential existing. Kann also als Prozentzahl gesehen werden. Die Zahl alleine sagt noch nicht allzuviel aus. Man kann aber randomisation tests machen, indem man x Netzwerke simuliert, die in etwa ähnlich zu dem vorhandenen sind und schaut, ob die "Edge Density" besonders auffällt. 

Hier könnte man auch die Density nur innerhalb von pol. Gruppen vergleichen und die "dichteste" Gruppe rausstellen etc.

```{r echo = F, warning = F}
edge_density(net_igraph)*100
```

## Average Path length

Beschreibt die durchschnittliche Pfadlänge, die man zurücklegen muss um zu einem anderen Knoten zu kommen. Der durchschnittliche Weg zwischen zwei Knoten also. Den finde ich hier mit `r mean_distance(net_igraph, directed=T)` auf Anhieb recht kurz, aber auch damit kann man random tests machen. Grundsätzlich hieße das aber, man kann fast immer zu einem guten "Multiplikator-MEP" kommen und über den zum Ziel.

```{r echo = F, warning = F}
mean_distance(net_igraph, directed = T)
```

Tatsächlich ist der Weg angeblich sogar relativ lang. Jedenfalls übernatürlich lang für ein Netzwerk der gleichen edge_density wie in unserem Originalnetzwerk. Davon habe ich 1000 simuliert und die Kanten werden zufällig zwischen die gleiche Anzahl an Knoten gesetzt. Für alle wird dann die MeanDistance errechnet und in einem Histogramm dargestellt. Das sieht jetzt schon relativ gestaucht aus, weil die alle eine mean_distance von 1.97 - 1.98 haben. Da liegt unsere mean_distance (rote Linie) dann signifikant drüber ;)

Letztlich könnten wir über so Techniken jedenfalls schauen, ob das MEP Netzwerk abweicht von Netzwerken, die die gleiche Anzahl von Knoten haben. Hier wäre die Interpretation, der Weg zwischen den MEPs ist länger als bei anderen Netzwerken mit gleicher Anzahl von Knoten und der gleichen Dichte von Verbindungen. Gesamt gesehen scheinen MEPs bei Twitter sich also eher unterdurchschnittlich oft zu folgen, was an Fraktionsbildung etc. liegen könnte. Man folgt eben nicht dem politischen Feind.

```{r echo = F, warning = F}
#sample_gnp(n = gorder(net_igraph), p = edge_density(net_igraph), directed = T)

# Generate 1000 random graphs

g_random <- vector('list',1000)

for(i in 1:1000){
  
  g_random[[i]] <- sample_gnp(n = gorder(net_igraph), 
                              p = edge_density(net_igraph), 
                              directed = T)
}

g_random_apl_meandis <- unlist(lapply(g_random, mean_distance, directed = T))

n_meandistance <- mean_distance(net_igraph, directed = T)
if (min(g_random_apl_meandis) > n_meandistance) {
  xlim_l <- n_meandistance
  xlim_u <- max(g_random_apl_meandis)
} else {
  xlim_l <- max(g_random_apl_meandis)
  xlim_u <- n_meandistance
}

hist(g_random_apl_meandis, breaks = 40, xlim = range(xlim_l, xlim_u))
abline(v = mean_distance(net_igraph, directed=T), col = "red", lty = 3, lwd=2)
```

## Transitivity

Gerade in Sozialen Netzwerken wichtig. Perfekte Transitivität würde bedeuten das X und Y miteinander verbunden sind, Y und Z auch und Z und X ebenfalls. Ab solchen Dreierkonstellationen, bei denen jeder mit jedem verbunden ist, redet man von Cliquen (siehe unten). Das ist in real vorkommenden Netzwerken allerdings selten. Der Transitivitäts-Koeffizient misst die Wahrscheinlichkeit, dass die benachbarten Knoten eines Knotens ebenfalls miteinander verbunden sind. Dies wird manchmal auch als Clustering-Koeffizient bezeichnet. In unserem Fall ist die Wahrscheinlichkeit bei etwa einem Drittel (wieder durch randomisation testbar, ob das viel oder wenig ist).

Die Transitivität kann auch lokal für jeden Knoten errechnet werden. Er nimmt dann quasi alle 3er-Konstellationen wo dieser Knoten dabei ist und guckt sich die beiden anderen Knoten an.

Hinweis: Ob das Netzwerk gerichtet ist oder nicht, wird dabei außer Acht gelassen.

```{r echo = F, warning = F}
#triangles(net_igraph)
transitivity(net_igraph)
```

Bei gleicher "Dichte" des Netzwerks ist es bei unserem Netzwerk deutlich wahrscheinlicher, dass auch die Nachbarn eines Knotens miteinander verbunden sind.

```{r echo = F, warning = F}
g_random_trans <- unlist(lapply(g_random, transitivity))

n_transitivity <- transitivity(net_igraph)
if (min(g_random_trans) > n_transitivity) {
  xlim_l <- n_transitivity
  xlim_u <- max(g_random_trans)
} else {
  xlim_l <- max(g_random_trans)
  xlim_u <- n_transitivity
}

hist(g_random_trans, breaks = 40, xlim = range(xlim_l, xlim_u))
abline(v = transitivity(net_igraph), col = "red", lty = 3, lwd=2)
```

## Cliquen

Cliquen sind Zusammenschlüsse von Knoten, die alle gegenseitig miteinander verbunden sind. In unserem Netzwerk gibt es `r count_max_cliques(net_igraph)` "größte" Cliquen die gleich groß sind. Diese verbinden jeweils `r clique_num(net_igraph)` Knoten miteinander.

```{r echo = F, warning = F}
largest.cliques(net_igraph)
#max_cliques(net_igraph) 
```

Daraus kann man ein Mandala machen. Viel Spaß beim Ausmalen :-P

```{r echo = F, warning = F}
g_lc <- largest_cliques(net_igraph)

g_clique1 <- as.undirected(induced_subgraph(net_igraph, g_lc[[1]]))


plot(g_clique1,
     vertex.label.color = "black", 
     vertex.label.cex = 0.9,
     vertex.size = 0,
     edge.color = 'gray28',
     main = "Largest Clique 1",
     layout = layout.circle(g_clique1)
)
```

## Assortativity

Der Assortativitätskoeffizient ist positiv, wenn ähnliche Knoten (basierend auf einer externen Eigenschaft) dazu neigen verbunden zu sein. Andernfalls ist er negativ. Theoretisch kann man hier diese externe Eigenschaft auch angeben, da stürzt mein R allerdings einfach ab.

In Standardfall wird die Assortativity auf Grundlage der Degrees (s.o.) berechnet. Also: Sind Knoten mit besonders vielen ein- und ausgehenden Kanten auch mit anderen high-degree-Knoten verbunden. Hier ist der Koeffizient `r round(assortativity.degree(net_igraph, directed=T),2)`. Man kann also nicht sagen, dass besonders zentrale Knoten anderen zentralen Knoten besonders stark folgen, aber auch nicht das Gegenteil. Das könnte dafür sprechen, dass es bspw. in jeder Fraktion Multiplikatoren gibt, die potentiell nur den high-degree-MEPs aus den anderen Fraktionen folgen und sonst eher den lower-degree-MEPs aus ihrer eigenen Fraktion.

```{r echo = F, warning = F}
assortativity.degree(net_igraph, directed=T)
```

## Reciprocity

Das Maß der Reziprozität definiert den Anteil der gegenseitigen Verbindungen in einem gerichteten Graphen. Funktioniert also nur bei gerichteten Graphen, unserer ist aber so einer, da MEP X ja bei Twitter MEP Y folgen kann, aber nicht zwangsläufig umgekehrt auch. Mit einem Wert von `r round(reciprocity(net_igraph),2)` werden knapp über die Hälfte der Follower auch zurück gefolgt.

## Community Detection

Theoretisch könnte man den Algorithmus auch selber Gruppen erkennen lassen. Da wir aber bereits auch schon vorgegebene Gruppen (Nation und Fraktion und nationale Partei haben wir schon im Datensatz) haben, müssten wir das mal besprechen, ob das Sinn ergibt.

# Analyse der Fraktionen

Die meisten Werte lassen sich auch innerhalb der einzelnen Fraktionen berechnen und dann miteinander vergleichen.

```{r echo = F, warning = F, message = F}
library(data.table)
library(stringr)

subgraph_list <- list("net_ALDE", "net_ECR","net_EFDD","net_ENF","net_EPP","net_Greens","net_GUE","net_SD","net_NI")
groupnames <- str_replace(subgraph_list, "net_","")

analyse_subgraphs <- function(subg_name){
  subg <- get(subg_name)
  subg_trans <- transitivity(subg)
  subg_assort <- assortativity.degree(subg, directed = T)
  subg_recip <- reciprocity(subg)
  subg_edgedens <- edge_density(subg)
  #subg_degree_out <- igraph::degree(subg, mode = "out")
  #subg_degree_in <- igraph::degree(subg, mode = "in")
  
  results_list <- list(
    #indegree = subg_degree_in,
    #outdegree = subg_degree_out,
    edgedensity = subg_edgedens,
    transitivity = subg_trans,
    assortativity = subg_assort,
    reciprocity = subg_recip
  )
  return(results_list)
}

subgraph_results <- lapply(subgraph_list, analyse_subgraphs) %>% 
  rbindlist() %>%
  mutate(group = groupnames) %>% 
  select(group, transitivity, assortativity, reciprocity, edgedensity) %>% 
  arrange(factor(group, levels = c("ENF","EFDD","ECR","EPP","ALDE","SD","Greens","GUE","NI"))) %>% 
  mutate_if(is.numeric, round, 3)

kable(subgraph_results)
```

Beispielsweise fällt auf, dass die beiden extremer rechten Fraktionen eine deutlich höhere Reziprozität aufweisen, als die übrigen. Tendenziell erkennt man häufiger ein "engeres" Verhältnis bei den Randparteien als bei den Parteien der Mitte. Sowas in die Richtung könnte man ebenfalls machen. Ich vermute, dass das eben auch an der Anzahl der Twitter-MEPs liegt, dass eben die EPP weit mehr davon hat und daher auch jeder EPP-MEP deutlich mehr anderen EPP folgen muss als das ein ENFler in seiner Fraktion müsste. Aber das kriegt man sicher noch irgendwie gewichtet, dass das besser vergleichbar ist.

# Graph

Natürlich lassen sich eben auch hübsche Bilder machen. Die Fraktionen erkennt man jedenfalls recht deutlich. Innerhalb der Fraktion folgt man sich eher als über Fraktionen hinweg. Interessant könnten aber auch die MEPs sein, die jetzt als andersfarbige Punkte im Gebiet der "falschen Fraktion" auftauchen.

```{r echo = F, warning = F, fig.width=12, fig.height=12}
V(net_igraph)$size <- 2
V(net_igraph)$frame.color <- "black"
V(net_igraph)$color <- V(net_igraph)$color_group
V(net_igraph)$label <- NA 
E(net_igraph)$arrow.mode <- 0


### EDGE colors

i <- 1
edge_list <- NULL

for(i in 1:ecount(net_igraph)) {
  end_name <- ends(net_igraph, i)[1]
  edge_list <- c(edge_list, end_name)
}

edge_list <- edge_list %>% as.data.frame() %>% 
  left_join(., select(full_list, screen_name, polgroup_short), by = c("."="screen_name")) %>% 
  mutate(edge_color = case_when(polgroup_short == "EPP" ~ "#3399FF", 
                           polgroup_short == "S&D" ~ "#FF0000",
                           polgroup_short == "ECR" ~ "#0000FF",
                           polgroup_short == "ALDE" ~ "yellow",
                           polgroup_short == "GUE/NGL" ~ "#990000",
                           polgroup_short == "Greens/EFA" ~ "#009900",
                           polgroup_short == "ENF" ~ "#2B3856",
                           polgroup_short == "EFDD" ~ "#24B9B9",
                           polgroup_short == "NI" ~ "#999999"))

E(net_igraph)$color <- edge_list$edge_color
E(net_igraph)$width <- 0.1


plot.igraph(net_igraph)
```

